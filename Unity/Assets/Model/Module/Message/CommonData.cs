// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CommonData.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using scg = global::System.Collections.Generic;
namespace ETModel {

  #region Enums
  public enum OpRetCode {
    Success = 0,
    RoomAlreadyIn = 200001,
    RoomAlreadyFull = 200002,
    RoomStateBan = 200003,
    RoomNotExist = 200004,
    LoginParamError = 200005,
    LoginAccPwdError = 200006,
    AccountAlreadyExist = 200007,
    AccountMaxUserIdError = 200008,
    UserGetInfoError = 200009,
    RoomNotEnoughCoin = 200010,
    RoomTooMuchCoin = 200011,
    RoomAlreadyGaming = 200012,
    RoomAlreadyOut = 200013,
    MatchAlreadyIn = 200014,
    MatchAlreadyOut = 200015,
    VerifyKeyInvalid = 200016,
    GateUserNotExist = 200017,
    KickOtherLogin = 200018,
    CreateRoomAlreadyIn = 200019,
    MatchIsClosed = 200020,
    RoomIsClosed = 200021,
    RoomConfigError = 200022,
    GameOpInvalid = 200023,
    MatchPlayerInvalid = 200024,
  }

  public enum PlayerState {
    None = 0,
    Online = 1,
    Ready = 2,
    /// <summary>
    ///托管
    /// </summary>
    Auto = 4,
    /// <summary>
    ///已看牌
    /// </summary>
    Check = 8,
    /// <summary>
    ///弃牌
    /// </summary>
    Fold = 16,
    /// <summary>
    ///暂离
    /// </summary>
    Leave = 32,
    /// <summary>
    ///观众
    /// </summary>
    Audience = 64,
  }

  public enum GameId {
    Default = 0,
    BullFight = 1,
  }

  #endregion

  #region Messages
  public partial class GamePlayerData : pb::IMessage {
    private static readonly pb::MessageParser<GamePlayerData> _parser = new pb::MessageParser<GamePlayerData>(() => (GamePlayerData)MessagePool.Instance.Fetch(typeof(GamePlayerData)));
    public static pb::MessageParser<GamePlayerData> Parser { get { return _parser; } }

    private int userId_;
    public int UserId {
      get { return userId_; }
      set {
        userId_ = value;
      }
    }

    private int head_;
    public int Head {
      get { return head_; }
      set {
        head_ = value;
      }
    }

    private int coin_;
    public int Coin {
      get { return coin_; }
      set {
        coin_ = value;
      }
    }

    private int pos_;
    public int Pos {
      get { return pos_; }
      set {
        pos_ = value;
      }
    }

    private string name_ = "";
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private global::ETModel.PlayerState state_ = 0;
    public global::ETModel.PlayerState State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (UserId != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(UserId);
      }
      if (Head != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(Head);
      }
      if (Coin != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(Coin);
      }
      if (Pos != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(Pos);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(Name);
      }
      if (State != 0) {
        output.WriteRawTag(56);
        output.WriteEnum((int) State);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (UserId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(UserId);
      }
      if (Head != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Head);
      }
      if (Coin != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Coin);
      }
      if (Pos != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Pos);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (State != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) State);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      userId_ = 0;
      head_ = 0;
      coin_ = 0;
      pos_ = 0;
      name_ = "";
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            UserId = input.ReadInt32();
            break;
          }
          case 24: {
            Head = input.ReadInt32();
            break;
          }
          case 32: {
            Coin = input.ReadInt32();
            break;
          }
          case 40: {
            Pos = input.ReadInt32();
            break;
          }
          case 50: {
            Name = input.ReadString();
            break;
          }
          case 56: {
            state_ = (global::ETModel.PlayerState) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  public partial class GameRoomData : pb::IMessage {
    private static readonly pb::MessageParser<GameRoomData> _parser = new pb::MessageParser<GameRoomData>(() => (GameRoomData)MessagePool.Instance.Fetch(typeof(GameRoomData)));
    public static pb::MessageParser<GameRoomData> Parser { get { return _parser; } }

    private int roomId_;
    public int RoomId {
      get { return roomId_; }
      set {
        roomId_ = value;
      }
    }

    private int state_;
    public int State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    private int roomType_;
    public int RoomType {
      get { return roomType_; }
      set {
        roomType_ = value;
      }
    }

    private int gameId_;
    public int GameId {
      get { return gameId_; }
      set {
        gameId_ = value;
      }
    }

    private int gameMode_;
    public int GameMode {
      get { return gameMode_; }
      set {
        gameMode_ = value;
      }
    }

    private int hallType_;
    public int HallType {
      get { return hallType_; }
      set {
        hallType_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (RoomId != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(RoomId);
      }
      if (State != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(State);
      }
      if (RoomType != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(RoomType);
      }
      if (GameId != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(GameId);
      }
      if (GameMode != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(GameMode);
      }
      if (HallType != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(HallType);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (RoomId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(RoomId);
      }
      if (State != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(State);
      }
      if (RoomType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(RoomType);
      }
      if (GameId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(GameId);
      }
      if (GameMode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(GameMode);
      }
      if (HallType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(HallType);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      roomId_ = 0;
      state_ = 0;
      roomType_ = 0;
      gameId_ = 0;
      gameMode_ = 0;
      hallType_ = 0;
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            RoomId = input.ReadInt32();
            break;
          }
          case 16: {
            State = input.ReadInt32();
            break;
          }
          case 24: {
            RoomType = input.ReadInt32();
            break;
          }
          case 32: {
            GameId = input.ReadInt32();
            break;
          }
          case 40: {
            GameMode = input.ReadInt32();
            break;
          }
          case 48: {
            HallType = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  public partial class UserInfo : pb::IMessage {
    private static readonly pb::MessageParser<UserInfo> _parser = new pb::MessageParser<UserInfo>(() => (UserInfo)MessagePool.Instance.Fetch(typeof(UserInfo)));
    public static pb::MessageParser<UserInfo> Parser { get { return _parser; } }

    private int userId_;
    public int UserId {
      get { return userId_; }
      set {
        userId_ = value;
      }
    }

    private int level_;
    public int Level {
      get { return level_; }
      set {
        level_ = value;
      }
    }

    private int coin_;
    public int Coin {
      get { return coin_; }
      set {
        coin_ = value;
      }
    }

    private int head_;
    public int Head {
      get { return head_; }
      set {
        head_ = value;
      }
    }

    private string name_ = "";
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (UserId != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(UserId);
      }
      if (Level != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Level);
      }
      if (Coin != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(Coin);
      }
      if (Head != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(Head);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Name);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (UserId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(UserId);
      }
      if (Level != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Level);
      }
      if (Coin != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Coin);
      }
      if (Head != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Head);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      userId_ = 0;
      level_ = 0;
      coin_ = 0;
      head_ = 0;
      name_ = "";
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            UserId = input.ReadInt32();
            break;
          }
          case 16: {
            Level = input.ReadInt32();
            break;
          }
          case 24: {
            Coin = input.ReadInt32();
            break;
          }
          case 32: {
            Head = input.ReadInt32();
            break;
          }
          case 42: {
            Name = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///游戏配置:控制游戏是否开启,房间模式等
  /// </summary>
  public partial class GameConfig : pb::IMessage {
    private static readonly pb::MessageParser<GameConfig> _parser = new pb::MessageParser<GameConfig>(() => (GameConfig)MessagePool.Instance.Fetch(typeof(GameConfig)));
    public static pb::MessageParser<GameConfig> Parser { get { return _parser; } }

    private long hallId_;
    public long HallId {
      get { return hallId_; }
      set {
        hallId_ = value;
      }
    }

    private int gameId_;
    public int GameId {
      get { return gameId_; }
      set {
        gameId_ = value;
      }
    }

    private int gameMode_;
    public int GameMode {
      get { return gameMode_; }
      set {
        gameMode_ = value;
      }
    }

    private int state_;
    public int State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    private int roomType_;
    public int RoomType {
      get { return roomType_; }
      set {
        roomType_ = value;
      }
    }

    private int minLimitCoin_;
    public int MinLimitCoin {
      get { return minLimitCoin_; }
      set {
        minLimitCoin_ = value;
      }
    }

    private int maxLimitCoin_;
    public int MaxLimitCoin {
      get { return maxLimitCoin_; }
      set {
        maxLimitCoin_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (HallId != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(HallId);
      }
      if (GameId != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(GameId);
      }
      if (GameMode != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(GameMode);
      }
      if (State != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(State);
      }
      if (RoomType != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(RoomType);
      }
      if (MinLimitCoin != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(MinLimitCoin);
      }
      if (MaxLimitCoin != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(MaxLimitCoin);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (HallId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(HallId);
      }
      if (GameId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(GameId);
      }
      if (GameMode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(GameMode);
      }
      if (State != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(State);
      }
      if (RoomType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(RoomType);
      }
      if (MinLimitCoin != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinLimitCoin);
      }
      if (MaxLimitCoin != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxLimitCoin);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      hallId_ = 0;
      gameId_ = 0;
      gameMode_ = 0;
      state_ = 0;
      roomType_ = 0;
      minLimitCoin_ = 0;
      maxLimitCoin_ = 0;
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            HallId = input.ReadInt64();
            break;
          }
          case 16: {
            GameId = input.ReadInt32();
            break;
          }
          case 24: {
            GameMode = input.ReadInt32();
            break;
          }
          case 32: {
            State = input.ReadInt32();
            break;
          }
          case 40: {
            RoomType = input.ReadInt32();
            break;
          }
          case 48: {
            MinLimitCoin = input.ReadInt32();
            break;
          }
          case 56: {
            MaxLimitCoin = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  public partial class MatchRoom : pb::IMessage {
    private static readonly pb::MessageParser<MatchRoom> _parser = new pb::MessageParser<MatchRoom>(() => (MatchRoom)MessagePool.Instance.Fetch(typeof(MatchRoom)));
    public static pb::MessageParser<MatchRoom> Parser { get { return _parser; } }

    private int roomId_;
    public int RoomId {
      get { return roomId_; }
      set {
        roomId_ = value;
      }
    }

    private int state_;
    public int State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    private int count_;
    public int Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (RoomId != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(RoomId);
      }
      if (State != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(State);
      }
      if (Count != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(Count);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (RoomId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(RoomId);
      }
      if (State != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(State);
      }
      if (Count != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Count);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      roomId_ = 0;
      state_ = 0;
      count_ = 0;
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            RoomId = input.ReadInt32();
            break;
          }
          case 16: {
            State = input.ReadInt32();
            break;
          }
          case 24: {
            Count = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
